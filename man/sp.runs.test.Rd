% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/sp.runs.test.R
\name{sp.runs.test}
\alias{sp.runs.test}
\title{Compute the global spatial runs test.}
\usage{
sp.runs.test(formula = NULL, data = NULL, na.action, fx = NULL,
listw = listw, alternative = "two.sided" , regular = FALSE,
distr = "asymptotic", nsim = NULL,control = list())
}
\arguments{
\item{formula}{a symbolic description of the factor (optional).}

\item{data}{an (optional) data frame or a sf object containing the variable to testing for.}

\item{fx}{a factor (optional).}

\item{listw}{una lista de vecinos (tipo knn o nb) o una matrix W que indique el orden de cada $m_i-entorno$
(por ejemplo de inversa distancia). Para calcular el número de rachas en cada m_i-entorno debe establecerse
un orden, por ejemplo del vecino más próximo al más lejano.}

\item{alternative}{a character string specifying the alternative hypothesis, must be one
of "two.sided" (default), "greater" or "less".}

\item{distr}{A string. Distribution of the test "asymptotic" (default) or "bootstrap"}

\item{nsim}{Number of permutations to obtain confidence intervals (CI).
Default value is NULL to don`t get CI of number of runs.}

\item{control}{List of additional control arguments.}
}
\value{
A object of the \emph{htest} and \emph{sprunstest} class
\tabular{ll}{
\code{data.name} \tab a character string giving the names of the data.\cr
\code{method} \tab the type of test applied ().\cr
\code{SR} \tab total number of runs \cr
\code{dnr} \tab empirical distribution of the number of runs \cr
\code{statistic} \tab Value of the homogeneity runs statistic. Negative sign indicates global homogeneity \cr
\code{alternative} \tab a character string describing the alternative hypothesis. \cr
\code{p.value} \tab p-value of the SRQ \cr
\code{pseudo.value} \tab the pseudo p-value of the SRQ test if nsim is not NULL\cr
\code{MeanNeig} \tab Mean of the Maximum number of neighborhood \cr
\code{MaxNeig} \tab Maximum number of neighborhood \cr
\code{listw} \tab The list of neighborhood \cr
\code{nsim} \tab number of boots (only for boots version) \cr
\code{SRGP} \tab nsim simulated values of statistic. \cr
\code{SRLP} \tab matrix with the number of runs for eacl localization. \cr
}
}
\description{
This function compute the global spatial runs test for spatial independence of a
categorical spatial data set.
}
\details{
El orden de las vecindades ($m_i-entornos$) es crítico. \cr
Para obetener el número de rachas observadas en cada $m_i-entorno$,
cada elemento debe asociarse a un conjunto de vecinos ordenados por proximidad.
Tres clases de listas pueden incluirse para identificar $m_i-entornos$:

\tabular{ll}{
\code{knn} \tab Matrices de la clase knn que consideran los vecinos por orden de proximidad.
Ver \code{\link{knn2knn_order}}\cr
\code{nb} \tab Si los vecinos se obtienen a partir de un objeto sf, el código internamente llamará
a la función \code{\link{nb2nb_order}} los ordenará en orden de proximidad de los centroides.  \cr
\code{matrix} \tab Si se introduce simplemente una matriz basasa en la inversa de la distancia,
también se llamará internamente a la función \code{\link{nb2nb_order}} para transformar la matriz
de la clase matrix a una matriz de la clase nb con vecinos ordenados. \cr
}

Two alternative sets of arguments can be included in this function to compute the spatial runs test:

\tabular{ll}{
\code{Option 1} \tab A factor (fx) and a list of neighborhood (\code{listw}) of the class knn. \cr
\code{Option 2} \tab A sf object (data) and formula to specify the factor. A list of neighborhood (listw) \cr
}
}
\section{Control arguments}{

\tabular{ll}{
\code{seedinit} \tab Numerical value for the seed (only for boot version). Default value seedinit=123 \cr
}
}

\examples{

# Case 1: SRQ test based on factor and knn
rm(list = ls())
n <- 100
cx <- runif(n)
cy <- runif(n)
x <- cbind(cx,cy)
listw <- knearneigh(cbind(cx,cy), k=3)
p <- c(1/6,3/6,2/6)
rho <- 0.5
fx <- dgp.spq(listw = listw, p = p, rho = rho)
srq <- sp.runs.test(fx = fx, listw = listw)
print(srq)
plot(srq)
# Version boots
control <- list(seedinit = 1255)
srq <- sp.runs.test(fx = fx, listw = listw, distr = "bootstrap" , nsim = 299, control = control)
print(srq)
plot(srq)

# Case 2: SRQ test with formula, a sf object (points) and knn
rm(list = ls())
data("FastFood")
x <- cbind(FastFood.sf$Lon,FastFood.sf$Lat)
listw <- spdep::knearneigh(x, k=4)
formula <- ~ Type
srq <- sp.runs.test(formula = formula, data = FastFood.sf, listw = listw)
print(srq)
plot(srq)
# Version boots
srq <- sp.runs.test(formula = formula, data = FastFood.sf, listw = listw, distr = "bootstrap", nsim = 199)
print(srq)
plot(srq)

# Case 3: SRQ test (permutation) using formula with a sf object (polygons) and nb
rm(list = ls())
library(sf)
fname <- system.file("shape/nc.shp", package="sf")
nc <- st_read(fname)
listw <- spdep::poly2nb(as(nc,"Spatial"), queen = FALSE)
p <- c(1/6,3/6,2/6)
rho = 0.5
co <- sf::st_coordinates(sf::st_centroid(nc))
nc$fx <- dgp.spq(listw = listw, p = p, rho = rho)
plot(nc["fx"])
formula <- ~ fx
srq <- sp.runs.test(formula = formula, data = nc, listw = listw, distr = "bootstrap", nsim = 399)
print(srq)
plot(srq)

# Case 4: SRQ test (Asymptotic) using formula with a sf object (polygons) and nb
rm(list = ls())
# PARA PROBAR ELEMENTOS SIN VECINOS
data(Spain)
listw <- spdep::poly2nb(spain.sf, queen = FALSE)
plot(spain.sf["Coast"])
formula <- ~ Coast
srq <- sp.runs.test(formula = formula, data = spain.sf, listw = listw)
print(srq)
plot(srq)
# Version boots
srq <- sp.runs.test(formula = formula, data = spain.sf, listw = listw, distr = "bootstrap", nsim = 299)
print(srq)
plot(srq)

# Case 5: SRQ test based on a distance matrix (inverse distance)
rm(list = ls())
N <- 100
cx <- runif(N)
cy <- runif(N)
data <- as.data.frame(cbind(cx,cy))
data <- st_as_sf(data,coords = c("cx","cy"))
n = dim(data)[1]
dis <- 1/matrix(as.numeric(st_distance(data,data)),ncol=n,nrow=n)
diag(dis) <- 0
dis <- (dis < quantile(dis,.10))*dis
p <- c(1/6,3/6,2/6)
rho <- 0.5
fx <- dgp.spq(listw = dis , p = p, rho = rho)
srq <- sp.runs.test(fx = fx, listw = dis)
print(srq)
plot(srq)

srq <- sp.runs.test(fx = fx, listw = dis, data = data)
print(srq)
plot(srq)
# Version boots
srq <- sp.runs.test(fx = fx, listw = dis, data = data, distr = "bootstrap", nsim = 299)
print(srq)
plot(srq)

# Case 6: SRQ test based on a distance matrix (inverse distance)
rm(list = ls())
data("FastFood")
n = dim(FastFood.sf)[1]
dis <- 1000000/matrix(as.numeric(st_distance(FastFood.sf,FastFood.sf)), ncol = n, nrow = n)
diag(dis) <- 0
dis <- (dis < quantile(dis,.005))*dis
p <- c(1/6,3/6,2/6)
rho = 0.5
co <- sf::st_coordinates(sf::st_centroid(FastFood.sf))
FastFood.sf$fx <- dgp.spq(p = p, listw = dis, rho = rho)
plot(FastFood.sf["fx"])
formula <- ~ fx
# Version boots
srq <- sp.runs.test(formula = formula, data = FastFood.sf, listw = dis, distr = "bootstrap", nsim = 299)
print(srq)
plot(srq)
}
\seealso{
\code{\link{local.sp.runs.test}}, \code{\link{dgp.spq}}, \code{\link{Q.test}},
}
\author{
\tabular{ll}{
Fernando López  \tab \email{fernando.lopez@upct.es} \cr
Román Mínguez  \tab \email{roman.minguez@uclm.es} \cr
Antonio Páez \tab \email{paezha@gmail.com} \cr
Manuel Ruiz \tab \email{manuel.ruiz@upct.es} \cr
}
@references
\itemize{
\item Ruiz, M., López, F., and Páez, A. (2010).
A test for global and local homogeneity of categorical data based on spatial runs.
\emph{Geographical Analysis}.
}
}
\keyword{association,}
\keyword{qualitative}
\keyword{runs}
\keyword{spatial}
\keyword{test}
\keyword{variable,}
